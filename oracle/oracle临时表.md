# oracle临时表
## 前言
　　目前所有使用 Oracle 作为数据库支撑平台的应用，大部分数据量比较庞大的系统，即表的数据量一般情况下都是在百万级以上的数据量。
　　当然在 Oracle 中创建分区是一种不错的选择，但是当你发现你的应用有多张表关联的时候，并且这些表大部分都是比较庞大，而你关联的时候发现其中的某一张或者某几张表关联之后得到的结果集非常小并且查询得到这个结果集的速度非常快，那么这个时候我考虑在 Oracle 中创建“临时表”。
　　我对临时表的理解：在 Oracle 中创建一张表，这个表不用于其他的什么功能，主要用于自己的软件系统一些特有功能才用的，而当你用完之后表中的数据就没用了。 Oracle 的临时表创建之后基本不占用表空间，如果你没有指定临时表(包括临时表的索引)存放的表空的时候，你插入到临时表的数据是存放在 ORACLE 系统的临时表空间中( TEMP )。

## 临时表的创建
### 会话级临时表
```sql
-- 会话级的临时表因为这这个临时表中的数据和你的当前会话有关系，当你当前SESSION 不退出的情况下，临时表中的数据就还存在，而当你退出当前SESSION 的时候，临时表中的数据就全部没有了，当然这个时候你如果以另外一个SESSION 登陆的时候是看不到另外一个SESSION 中插入到临时表中的数据的。即两个不同的SESSION 所插入的数据是互不相干的。当某一个SESSION 退出之后临时表中的数据就被截断(truncate table ，即数据清空)了。会话级的临时表创建方法：
Create Global Temporary Table Table_Name  
(Col1 Type1,Col2 Type2...) On Commit Preserve Rows ; 
```

### 事物级临时表
```sql
-- 事务级临时表是指该临时表与事务相关，当进行事务提交或者事务回滚的时候，临时表中的数据将自行被截断，其他的内容和会话级的临时表的一致(包括退出SESSION 的时候，事务级的临时表也会被自动截断)。事务级临时表的创建方法：
Create Global Temporary Table Table_Name  
(Col1 Type1,Col2 Type2...) On Commit Delete Rows ;
```

### 两中类型临时表的区别
会话级临时表采用 on commit preserve rows ;而事务级则采用 on commit delete rows ;用法上，会话级别只有当会话结束临时表中的数据才会被截断，而且事务级临时表则不管是 commit 、 rollback 或者是会话结束，临时表中的数据都将被截断

## 什么时候使用临时表
- 当某一个 SQL 语句关联的表在 2 张及以上，并且和一些小表关联。可以采用将大表进行分拆并且得到比较小的结果集合存放在临时表中
- 程序执行过程中可能需要存放一些临时的数据，这些数据在整个程序的会话过程中都需要用的等等。